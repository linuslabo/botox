'use strict';

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _require = require("../utils");

var getField = _require.getField;
var tryDoc = _require.tryDoc;

module.exports = {
  'array': [readArray, writeArray, sizeOfArray],
  'count': [readCount, writeCount, sizeOfCount],
  'container': [readContainer, writeContainer, sizeOfContainer]
};

function evalCount(count, fields) {
  if (fields[count["field"]] in count["map"]) return count["map"][fields[count["field"]]];
  return count["default"];
}

function readArray(buffer, offset, _ref, rootNode) {
  var _this = this;

  var type = _ref.type;
  var count = _ref.count;
  var countType = _ref.countType;
  var countTypeArgs = _ref.countTypeArgs;

  var results = {
    value: [],
    size: 0
  };
  var c;
  if (typeof count === "object") c = evalCount(count, rootNode);else if (typeof count !== "undefined") c = getField(count, rootNode);else if (typeof countType !== "undefined") {
    var _tryDoc = tryDoc(function () {
      return _this.read(buffer, offset, { type: countType, typeArgs: countTypeArgs }, rootNode);
    }, "$count");

    var size = _tryDoc.size;
    var value = _tryDoc.value;

    results.size += size;
    offset += size;
    c = value;
  } else // TODO : broken schema, should probably error out.
    c = 0;
  for (var i = 0; i < c; i++) {
    var _tryDoc2 = tryDoc(function () {
      return _this.read(buffer, offset, type, rootNode);
    }, i);

    size = _tryDoc2.size;
    value = _tryDoc2.value;

    results.size += size;
    offset += size;
    results.value.push(value);
  }
  return results;
}

function writeArray(value, buffer, offset, _ref2, rootNode) {
  var _this2 = this;

  var type = _ref2.type;
  var count = _ref2.count;
  var countType = _ref2.countType;
  var countTypeArgs = _ref2.countTypeArgs;

  if (typeof count === "undefined" && typeof countType !== "undefined") offset = tryDoc(function () {
    return _this2.write(value.length, buffer, offset, { type: countType, typeArgs: countTypeArgs }, rootNode);
  }, "$count");else if (typeof count === "undefined") {// Broken schema, should probably error out
  }
  return value.reduce(function (offset, v, index) {
    return tryDoc(function () {
      return _this2.write(v, buffer, offset, type, rootNode);
    }, index);
  }, offset);
}

function sizeOfArray(value, _ref3, rootNode) {
  var _this3 = this;

  var type = _ref3.type;
  var count = _ref3.count;
  var countType = _ref3.countType;
  var countTypeArgs = _ref3.countTypeArgs;

  var size = 0;
  if (typeof count === "undefined" && typeof countType !== "undefined") size = tryDoc(function () {
    return _this3.sizeOf(value.length, { type: countType, typeArgs: countTypeArgs }, rootNode);
  }, "$count");

  return value.reduce(function (size, v, index) {
    return tryDoc(function () {
      return size + _this3.sizeOf(v, type, rootNode);
    }, index);
  }, size);
}

function readContainer(buffer, offset, typeArgs, context) {
  var _this4 = this;

  var results = {
    value: { "..": context },
    size: 0
  };
  typeArgs.forEach(function (_ref4) {
    var type = _ref4.type;
    var name = _ref4.name;
    var anon = _ref4.anon;

    tryDoc(function () {
      var readResults = _this4.read(buffer, offset, type, results.value);
      results.size += readResults.size;
      offset += readResults.size;
      if (anon) {
        if (readResults.value !== undefined) _Object$keys(readResults.value).forEach(function (key) {
          results.value[key] = readResults.value[key];
        });
      } else results.value[name] = readResults.value;
    }, name ? name : "unknown");
  });
  delete results.value[".."];
  return results;
}

function writeContainer(value, buffer, offset, typeArgs, context) {
  var _this5 = this;

  value[".."] = context;
  offset = typeArgs.reduce(function (offset, _ref5) {
    var type = _ref5.type;
    var name = _ref5.name;
    var anon = _ref5.anon;
    return tryDoc(function () {
      return _this5.write(anon ? value : value[name], buffer, offset, type, value);
    }, name ? name : "unknown");
  }, offset);
  delete value[".."];
  return offset;
}

function sizeOfContainer(value, typeArgs, context) {
  var _this6 = this;

  value[".."] = context;
  var size = typeArgs.reduce(function (size, _ref6) {
    var type = _ref6.type;
    var name = _ref6.name;
    var anon = _ref6.anon;
    return size + tryDoc(function () {
      return _this6.sizeOf(anon ? value : value[name], type, value);
    }, name ? name : "unknown");
  }, 0);
  delete value[".."];
  return size;
}

function readCount(buffer, offset, _ref7, rootNode) {
  var type = _ref7.type;

  return this.read(buffer, offset, type, rootNode);
}

function writeCount(value, buffer, offset, _ref8, rootNode) {
  var countFor = _ref8.countFor;
  var type = _ref8.type;

  // Actually gets the required field, and writes its length. Value is unused.
  // TODO : a bit hackityhack.
  return this.write(getField(countFor, rootNode).length, buffer, offset, type, rootNode);
}

function sizeOfCount(value, _ref9, rootNode) {
  var countFor = _ref9.countFor;
  var type = _ref9.type;

  // TODO : should I use value or getField().length ?
  return this.sizeOf(getField(countFor, rootNode).length, type, rootNode);
}
//# sourceMappingURL=../maps/datatypes/structures.js.map
