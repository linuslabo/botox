'use strict';

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var assert = require('assert');

var _require = require("../utils");

var getField = _require.getField;
var tryDoc = _require.tryDoc;

module.exports = {
  'varint': [readVarInt, writeVarInt, sizeOfVarInt],
  'bool': [readBool, writeBool, 1],
  'pstring': [readPString, writePString, sizeOfPString],
  'buffer': [readBuffer, writeBuffer, sizeOfBuffer],
  'void': [readVoid, writeVoid, 0],
  'bitfield': [readBitField, writeBitField, sizeOfBitField],
  'cstring': [readCString, writeCString, sizeOfCString],
  'mapper': [readMapper, writeMapper, sizeOfMapper]
};

function readMapper(buffer, offset, _ref, rootNode) {
  var type = _ref.type;
  var mappings = _ref.mappings;

  var _read = this.read(buffer, offset, type, rootNode);

  var size = _read.size;
  var value = _read.value;

  var results = {
    size: size,
    value: mappings[value]
  };
  if (results.value == undefined) throw new Error(value + " is not in the mappings value");
  return results;
}

function writeMapper(value, buffer, offset, _ref2, rootNode) {
  var type = _ref2.type;
  var mappings = _ref2.mappings;

  var keys = _Object$keys(mappings);
  var mappedValue = null;
  for (var i = 0; i < keys.length; i++) {
    if (mappings[keys[i]] == value) {
      mappedValue = keys[i];
      break;
    }
  }
  if (mappedValue == null) throw new Error(value + " is not in the mappings value");
  return this.write(mappedValue, buffer, offset, type, rootNode);
}

function sizeOfMapper(value, _ref3, rootNode) {
  var type = _ref3.type;
  var mappings = _ref3.mappings;

  var keys = _Object$keys(mappings);
  var mappedValue = null;
  for (var i = 0; i < keys.length; i++) {
    if (mappings[keys[i]] == value) {
      mappedValue = keys[i];
      break;
    }
  }
  if (mappedValue == null) throw new Error(value + " is not in the mappings value");
  return this.sizeOf(mappedValue, type, rootNode);
}

function readVarInt(buffer, offset) {
  var result = 0;
  var shift = 0;
  var cursor = offset;

  while (true) {
    if (cursor + 1 > buffer.length) return null;
    var b = buffer.readUInt8(cursor);
    result |= (b & 0x7f) << shift; // Add the bits to our number, except MSB
    cursor++;
    if (!(b & 0x80)) {
      // If the MSB is not set, we return the number
      return {
        value: result,
        size: cursor - offset
      };
    }
    shift += 7; // we only have 7 bits, MSB being the return-trigger
    assert.ok(shift < 64, "varint is too big"); // Make sure our shift don't overflow.
  }
}

function sizeOfVarInt(value) {
  var cursor = 0;
  while (value & ~0x7F) {
    value >>>= 7;
    cursor++;
  }
  return cursor + 1;
}

function writeVarInt(value, buffer, offset) {
  var cursor = 0;
  while (value & ~0x7F) {
    buffer.writeUInt8(value & 0xFF | 0x80, offset + cursor);
    cursor++;
    value >>>= 7;
  }
  buffer.writeUInt8(value, offset + cursor);
  return offset + cursor + 1;
}

function readPString(buffer, offset, _ref4, rootNode) {
  var _this = this;

  var countType = _ref4.countType;
  var countTypeArgs = _ref4.countTypeArgs;

  var _tryDoc = tryDoc(function () {
    return _this.read(buffer, offset, { type: countType, typeArgs: countTypeArgs }, rootNode);
  }, "$count");

  var size = _tryDoc.size;
  var value = _tryDoc.value;

  var cursor = offset + size;
  var strEnd = cursor + value;
  if (strEnd > buffer.length) throw new Error("Missing characters in string, found size is " + buffer.length + " expected size was " + strEnd);

  return {
    value: buffer.toString('utf8', cursor, strEnd),
    size: strEnd - offset
  };
}

function writePString(value, buffer, offset, _ref5, rootNode) {
  var _this2 = this;

  var countType = _ref5.countType;
  var countTypeArgs = _ref5.countTypeArgs;

  var length = Buffer.byteLength(value, 'utf8');
  offset = tryDoc(function () {
    return _this2.write(length, buffer, offset, { type: countType, typeArgs: countTypeArgs }, rootNode);
  }, "$count");
  buffer.write(value, offset, length, 'utf8');
  return offset + length;
}

function sizeOfPString(value, _ref6, rootNode) {
  var _this3 = this;

  var countType = _ref6.countType;
  var countTypeArgs = _ref6.countTypeArgs;

  var length = Buffer.byteLength(value, 'utf8');
  var size = tryDoc(function () {
    return _this3.sizeOf(length, { type: countType, typeArgs: countTypeArgs }, rootNode);
  }, "$count");
  return size + length;
}

function readBool(buffer, offset) {
  if (offset + 1 > buffer.length) return null;
  var value = buffer.readInt8(offset);
  return {
    value: !!value,
    size: 1
  };
}

function writeBool(value, buffer, offset) {
  buffer.writeInt8(+value, offset);
  return offset + 1;
}

function readBuffer(buffer, offset, _ref7, rootNode) {
  var count = _ref7.count;
  var countType = _ref7.countType;
  var countTypeArgs = _ref7.countTypeArgs;

  var totalSize = 0;
  var totalCount;
  if (typeof count !== "undefined") totalCount = getField(count, rootNode);else if (typeof countType !== "undefined") {
    var _read2 = this.read(buffer, offset, { type: countType, typeArgs: countTypeArgs }, rootNode);

    var value = _read2.value;
    var size = _read2.size;

    totalSize += size;
    offset += size;
    totalCount = value;
  }
  return {
    value: buffer.slice(offset, offset + totalCount),
    size: totalSize + totalCount
  };
}

function writeBuffer(value, buffer, offset, _ref8, rootNode) {
  var count = _ref8.count;
  var countType = _ref8.countType;
  var countTypeArgs = _ref8.countTypeArgs;

  if (typeof count === "undefined" && typeof countType !== "undefined") {
    offset = this.write(value.length, buffer, offset, { type: countType, typeArgs: countTypeArgs }, rootNode);
  } else if (typeof count === "undefined") {// Broken schema, should probably error out
  }
  value.copy(buffer, offset);
  return offset + value.length;
}

function sizeOfBuffer(value, _ref9, rootNode) {
  var count = _ref9.count;
  var countType = _ref9.countType;
  var countTypeArgs = _ref9.countTypeArgs;

  var size = 0;
  if (typeof count === "undefined" && typeof countType !== "undefined") {
    size = this.sizeOf(value.length, { type: countType, typeArgs: countTypeArgs }, rootNode);
  }
  return size + value.length;
}

function readVoid() {
  return {
    value: undefined,
    size: 0
  };
}

function writeVoid(value, buffer, offset) {
  return offset;
}

function generateBitMask(n) {
  return (1 << n) - 1;
}

function readBitField(buffer, offset, typeArgs) {
  var beginOffset = offset;
  var curVal = null;
  var bits = 0;
  var results = {};
  results.value = typeArgs.reduce(function (acc, _ref10) {
    var size = _ref10.size;
    var signed = _ref10.signed;
    var name = _ref10.name;

    var currentSize = size;
    var val = 0;
    while (currentSize > 0) {
      if (bits == 0) {
        curVal = buffer[offset++];
        bits = 8;
      }
      var bitsToRead = Math.min(currentSize, bits);
      val = val << bitsToRead | (curVal & generateBitMask(bits)) >> bits - bitsToRead;
      bits -= bitsToRead;
      currentSize -= bitsToRead;
    }
    if (signed && val >= 1 << size - 1) val -= 1 << size;
    acc[name] = val;
    return acc;
  }, {});
  results.size = offset - beginOffset;
  return results;
}
function writeBitField(value, buffer, offset, typeArgs) {
  var toWrite = 0;
  var bits = 0;
  typeArgs.forEach(function (_ref11) {
    var size = _ref11.size;
    var signed = _ref11.signed;
    var name = _ref11.name;

    var val = value[name];
    if (!signed && val < 0 || signed && val < -(1 << size - 1)) throw new Error(value + " < " + signed ? -(1 << size - 1) : 0);else if (!signed && val >= 1 << size || signed && val >= (1 << size - 1) - 1) throw new Error(value + " >= " + signed ? 1 << size : (1 << size - 1) - 1);
    while (size > 0) {
      var writeBits = Math.min(8 - bits, size);
      toWrite = toWrite << writeBits | val >> size - writeBits & generateBitMask(writeBits);
      size -= writeBits;
      bits += writeBits;
      if (bits === 8) {
        buffer[offset++] = toWrite;
        bits = 0;
        toWrite = 0;
      }
    }
  });
  if (bits != 0) buffer[offset++] = toWrite << 8 - bits;
  return offset;
}

function sizeOfBitField(value, typeArgs) {
  return Math.ceil(typeArgs.reduce(function (acc, _ref12) {
    var size = _ref12.size;

    return acc + size;
  }, 0) / 8);
}

function readCString(buffer, offset) {
  var str = "";
  while (offset < buffer.length && buffer[offset] != 0x00) str += buffer[offset++];
  if (offset < buffer.length) return null;else return str;
}

function writeCString(value, buffer, offset) {
  buffer.write(value, offset);
  offset += value.length;
  buffer.writeInt8(0x00, offset);
  return offset + 1;
}

function sizeOfCString(value) {
  return value.length + 1;
}
//# sourceMappingURL=../maps/datatypes/utils.js.map
